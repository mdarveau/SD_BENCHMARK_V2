// main/app_main.c
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include "esp_err.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_heap_caps.h"
#include "driver/gpio.h"
#include "driver/sdspi_host.h"
#include "driver/spi_common.h"
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "SD_BENCH";

/* === Pins (change if needed) === */
#define SD_CS   15
#define SD_MISO 12
#define SD_MOSI 13
#define SD_SCK  14

/* === Paths & tunables === */
#define MOUNT_POINT "/sdcard"
#define TEST_FILE_VFS  MOUNT_POINT "/DROPLE~5.WAV"

#define VFS_READ_CHUNK_KB   64              // fread chunk
static const int STDIO_TRY_KB[] = {256, 128, 64};     // dynamic fallbacks

#define RAW_XFER_SECTORS    256             // 128 KB per transfer
#define RAW_TOTAL_MB          8
#define RAW_START_LBA      4096

#ifndef CHECK
#define CHECK(call, msg) do {                   \
    esp_err_t __e = (call);                     \
    if (__e != ESP_OK) {                        \
        ESP_LOGE(TAG, "%s: %s", msg, esp_err_to_name(__e)); \
        return __e;                              \
    }                                           \
} while (0)
#endif

static sdmmc_card_t *s_card = NULL;
static int s_host_slot = SPI2_HOST; // HSPI

static double kbps(size_t bytes, int64_t us) {
    if (us <= 0) return 0.0;
    return (bytes / 1024.0) / (us / 1000000.0);
}

static void list_files(const char* dirpath) {
    DIR *dir = opendir(dirpath);
    if (!dir) { ESP_LOGW(TAG, "Could not open %s", dirpath); return; }
    struct dirent *e;
    while ((e = readdir(dir)) != NULL) ESP_LOGI(TAG, "FILE: %s/%s", dirpath, e->d_name);
    closedir(dir);
}

/* ---- fread benchmark with dynamic INTERNAL stdio buffer ---- */
static void bench_vfs_fread(const char* path) {
    FILE *fp = fopen(path, "rb");
    if (!fp) { ESP_LOGE(TAG, "fopen(%s) failed", path); return; }

    // Try to allocate an INTERNAL stdio buffer: 128K -> 64K -> 32K -> 16K
    uint8_t *stdio_buf = NULL;
    int chosen_kb = 0;
    for (size_t i = 0; i < sizeof(STDIO_TRY_KB)/sizeof(STDIO_TRY_KB[0]); ++i) {
        size_t bytes = STDIO_TRY_KB[i] * 1024;
        stdio_buf = (uint8_t*)heap_caps_malloc(bytes, MALLOC_CAP_INTERNAL);
        if (stdio_buf) { setvbuf(fp, (char*)stdio_buf, _IOFBF, bytes); chosen_kb = STDIO_TRY_KB[i]; break; }
    }
    if (stdio_buf) ESP_LOGI(TAG, "VFS stdio buffer: %d KB (INTERNAL)", chosen_kb);
    else           ESP_LOGW(TAG, "No INTERNAL stdio buffer; using default (slow)");

    // One-shot path disabled (unstable across runs); using fixed chunking

    // Choose a read chunk size with fallbacks (128K -> 64K -> 32K -> 16K)
    static const int READ_TRY_KB[] = {64, 32, 16};
    size_t chunk_bytes = 0;
    uint8_t *buf = NULL;
    for (size_t i = 0; i < sizeof(READ_TRY_KB)/sizeof(READ_TRY_KB[0]); ++i) {
        size_t try_bytes = READ_TRY_KB[i] * 1024;
        // Try INTERNAL first
        buf = (uint8_t*)heap_caps_malloc(try_bytes, MALLOC_CAP_INTERNAL);
        if (!buf) {
            // Try generic 8-bit capable RAM
            buf = (uint8_t*)heap_caps_malloc(try_bytes, MALLOC_CAP_8BIT);
        }
        if (!buf) {
            // Try default heap as a last resort
            buf = (uint8_t*)heap_caps_malloc(try_bytes, 0);
        }
        if (buf) { chunk_bytes = try_bytes; break; }
    }
    if (!buf) { ESP_LOGE(TAG, "No read buffer (all sizes failed)"); if (stdio_buf) heap_caps_free(stdio_buf); fclose(fp); return; }
    ESP_LOGI(TAG, "VFS fread chunk: %u KB", (unsigned)(chunk_bytes/1024));

    ESP_LOGI(TAG, "VFS fread: %s in %u KB chunks...", path, (unsigned)(chunk_bytes/1024));

    int64_t t0 = esp_timer_get_time();
    size_t total = 0;
    for (;;) {
        size_t br = fread(buf, 1, chunk_bytes, fp);
        total += br;
        if (br < chunk_bytes) break;
    }
    int64_t dt = esp_timer_get_time() - t0;

    ESP_LOGI(TAG, "VFS fread %u bytes in %lld us: %.1f KB/s (%.2f MB/s)",
             (unsigned)total, (long long)dt, kbps(total, dt), kbps(total, dt)/1024.0);

    heap_caps_free(buf);
    if (stdio_buf) heap_caps_free(stdio_buf);
    fclose(fp);
}

/* ---- Raw sector benchmark (bus ceiling) ---- */
static void bench_raw_read(void) {
    if (!s_card) { ESP_LOGE(TAG, "No card"); return; }
    const size_t SECTOR = 512;
    const size_t PER_XFER_BYTES = RAW_XFER_SECTORS * SECTOR;
    const size_t TOTAL_BYTES = RAW_TOTAL_MB * 1024 * 1024;
    const size_t TOTAL_XFERS = (TOTAL_BYTES + PER_XFER_BYTES - 1) / PER_XFER_BYTES;

    uint8_t* buf = (uint8_t*)heap_caps_malloc(PER_XFER_BYTES, MALLOC_CAP_DMA);
    if (!buf) { ESP_LOGE(TAG, "No DMA buffer"); return; }

    ESP_LOGI(TAG, "RAW: %u MB from LBA %u, %u sectors/transfer (%.0f KB)",
             RAW_TOTAL_MB, RAW_START_LBA, RAW_XFER_SECTORS, PER_XFER_BYTES/1024.0);

    int64_t t0 = esp_timer_get_time();
    size_t total = 0; uint32_t lba = RAW_START_LBA;
    for (size_t i = 0; i < TOTAL_XFERS; ++i) {
        esp_err_t ret = sdmmc_read_sectors(s_card, buf, lba, RAW_XFER_SECTORS);
        if (ret != ESP_OK) { ESP_LOGE(TAG, "read LBA=%u, n=%u -> %s", lba, RAW_XFER_SECTORS, esp_err_to_name(ret)); break; }
        total += PER_XFER_BYTES; lba += RAW_XFER_SECTORS;
    }
    int64_t dt = esp_timer_get_time() - t0;

    ESP_LOGI(TAG, "RAW read %u bytes in %lld us: %.1f KB/s (%.2f MB/s)",
             (unsigned)total, (long long)dt, kbps(total, dt), kbps(total, dt)/1024.0);

    heap_caps_free(buf);
}

/* ---- SD init/mount (SPI @ 20 MHz, stronger drive) ---- */
static esp_err_t init_and_mount_sdcard_at(int max_freq_khz) {
    ESP_LOGI(TAG, "Initializing SD (SPI mode) @ %d kHz...", max_freq_khz);
    // Uncomment for retry diagnostics:
    // esp_log_level_set("sdspi_transaction", ESP_LOG_INFO);
    // esp_log_level_set("sdspi_host", ESP_LOG_INFO);

    sdmmc_host_t host = SDSPI_HOST_DEFAULT();
    host.slot = s_host_slot;     // HSPI
    host.max_freq_khz = max_freq_khz;

    // Stronger drive can help at higher toggle rates
    gpio_set_drive_capability(SD_MOSI, GPIO_DRIVE_CAP_3);
    gpio_set_drive_capability(SD_MISO, GPIO_DRIVE_CAP_3);
    gpio_set_drive_capability(SD_SCK,  GPIO_DRIVE_CAP_3);
    gpio_set_drive_capability(SD_CS,   GPIO_DRIVE_CAP_3);

    spi_bus_config_t bus_cfg = {
        .mosi_io_num = SD_MOSI,
        .miso_io_num = SD_MISO,
        .sclk_io_num = SD_SCK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 128 * 1024
    };
    CHECK(spi_bus_initialize(host.slot, &bus_cfg, SPI_DMA_CH_AUTO), "spi_bus_initialize");

    sdspi_device_config_t slot_cfg = SDSPI_DEVICE_CONFIG_DEFAULT();
    slot_cfg.gpio_cs = SD_CS;
    slot_cfg.host_id = host.slot;

    esp_vfs_fat_sdmmc_mount_config_t mount_cfg = {
        .format_if_mount_failed = false,
        .max_files = 5,
        .allocation_unit_size = 0,
        .disk_status_check_enable = false
    };

    esp_err_t err = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &host, &slot_cfg, &mount_cfg, &s_card);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "mount/init failed: %s", esp_err_to_name(err));
        return err;
    }
    sdmmc_card_print_info(stdout, s_card);
    ESP_LOGI(TAG, "card->max_freq_khz=%d (host asked %d)", s_card->max_freq_khz, max_freq_khz);
    return ESP_OK;
}

static void unmount_and_free_bus(void) {
    if (s_card) {
        esp_vfs_fat_sdcard_unmount(MOUNT_POINT, s_card);
        s_card = NULL;
    }
    spi_bus_free(s_host_slot);
}

static void raw_warmup_read(void) {
    if (!s_card) return;
    const size_t SECTOR = 512;
    const size_t sectors = 256; // 128KB
    uint8_t* buf = (uint8_t*)heap_caps_malloc(sectors * SECTOR, MALLOC_CAP_DMA);
    if (!buf) return;
    esp_err_t ret = sdmmc_read_sectors(s_card, buf, RAW_START_LBA, sectors);
    (void)ret; // ignore result; warmup only
    heap_caps_free(buf);
}

/* ---- Run it in a modest stack to free INTERNAL RAM ---- */
static void bench_task(void* arg) {
    const int freqs_khz[] = {20000, 24000, 26000, 27000, 40000};
    size_t nf = sizeof(freqs_khz)/sizeof(freqs_khz[0]);
    for (size_t i = 0; i < nf; ++i) {
        if (init_and_mount_sdcard_at(freqs_khz[i]) != ESP_OK) { unmount_and_free_bus(); continue; }
        ESP_LOGI(TAG, "Listing %s:", MOUNT_POINT);
        list_files(MOUNT_POINT);
        bench_vfs_fread(TEST_FILE_VFS);
        bench_raw_read();
        unmount_and_free_bus();
    }
    ESP_LOGI(TAG, "Bench complete.");
    vTaskDelete(NULL);
}

void app_main(void) {
    // Smaller stack (10 KB) so large INTERNAL buffers are more likely to succeed
    const uint32_t stack_words = (10 * 1024) / sizeof(StackType_t);
    xTaskCreatePinnedToCore(bench_task, "bench_task", stack_words, NULL, tskIDLE_PRIORITY+1, NULL, tskNO_AFFINITY);
}
