// main/app_main.c
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

#include "driver/gpio.h"
#include "driver/sdspi_host.h"
#include "driver/spi_common.h"
#include "esp_err.h"
#include "esp_heap_caps.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_vfs_fat.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "sdmmc_cmd.h"

static const char *TAG = "SD_BENCH";

/* === Pins (change if needed) === */
#define SD_CS 15
#define SD_MISO 12
#define SD_MOSI 13
#define SD_SCK 14

/* === Paths & tunables === */
#define MOUNT_POINT "/sdcard"
#define TEST_FILE_VFS_SMALL MOUNT_POINT "/DROPLE~5.WAV"
#define TEST_FILE_VFS_LARGE MOUNT_POINT "/BACKGR~3.WAV"

#define RAW_XFER_SECTORS 256  // 128 KB per transfer
#define RAW_TOTAL_MB 8
#define RAW_START_LBA 4096

/* === Buffer size configuration === */
#define STDIO_BUF_PREFERRED_KB 128  // Preferred stdio buffer size
#define DMA_BUF_PREFERRED_KB 32     // Preferred DMA buffer size

#ifndef CHECK
#define CHECK(call, msg)                                  \
  do {                                                    \
    esp_err_t __e = (call);                               \
    if (__e != ESP_OK) {                                  \
      ESP_LOGE(TAG, "%s: %s", msg, esp_err_to_name(__e)); \
      return __e;                                         \
    }                                                     \
  } while (0)
#endif

static sdmmc_card_t *s_card = NULL;
static int s_host_slot = SPI2_HOST;  // HSPI

// Forward declarations for helpers used before their definitions
static void unmount_and_free_bus(void);

static double kbps(size_t bytes, int64_t us) {
  if (us <= 0) return 0.0;
  return (bytes / 1024.0) / (us / 1000000.0);
}

static void list_files(const char *dirpath) {
  ESP_LOGI(TAG, "Listing %s:", MOUNT_POINT);
  DIR *dir = opendir(dirpath);
  if (!dir) {
    ESP_LOGW(TAG, "Could not open %s", dirpath);
    return;
  }
  struct dirent *e;
  while ((e = readdir(dir)) != NULL)
    ESP_LOGI(TAG, "FILE: %s/%s", dirpath, e->d_name);
  closedir(dir);
}

static void bench_vfs_fread(const char *path) {
  // Check available memory before allocation
  size_t free_internal = heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
  ESP_LOGI(TAG, "Available internal memory: %zu bytes", free_internal);

  FILE *fp = fopen(path, "rb");
  if (!fp) {
    ESP_LOGE(TAG, "fopen(%s) failed", path);
    return;
  }

  size_t stdio_buf_size = STDIO_BUF_PREFERRED_KB * 1024;
  uint8_t *stdio_buf = (uint8_t *)heap_caps_aligned_alloc(64, stdio_buf_size,
                                                          MALLOC_CAP_INTERNAL);

  if (stdio_buf) {
    setvbuf(fp, (char *)stdio_buf, _IOFBF, stdio_buf_size);
    ESP_LOGI(TAG, "Using %zu KB stdio buffer", stdio_buf_size / 1024);
  } else {
    // Use unbuffered I/O to avoid potential buffer issues
    setvbuf(fp, NULL, _IONBF, 0);
    ESP_LOGW(TAG, "Using unbuffered I/O (no stdio buffer)");
  }

  // DMA chunk: Use 32-byte alignment for better SD card compatibility
  size_t chunk_bytes = DMA_BUF_PREFERRED_KB * 1024;
  uint8_t *buf =
      (uint8_t *)heap_caps_aligned_alloc(32, chunk_bytes, MALLOC_CAP_DMA);

  if (!buf) {
    ESP_LOGE(TAG, "No DMA read buffer available");
    fclose(fp);
    if (stdio_buf) heap_caps_free(stdio_buf);
    return;
  }

  // Validate buffer alignment
  ESP_LOGI(TAG, "DMA buffer allocated at 0x%p, size %zu bytes", buf,
           chunk_bytes);
  ESP_LOGI(TAG, "Buffer alignment check: %s",
           ((uintptr_t)buf % 32 == 0) ? "OK" : "FAIL");

  ESP_LOGI(TAG, "fread: %s in %u KB chunks...", path,
           (unsigned)(chunk_bytes / 1024));
  ESP_LOGI(TAG, "Total buffer memory: %zu KB (stdio: %zu KB, DMA: %zu KB)",
           (stdio_buf_size + chunk_bytes) / 1024, stdio_buf_size / 1024,
           chunk_bytes / 1024);

  int64_t t0 = esp_timer_get_time();
  size_t total = 0;
  int read_count = 0;

  ESP_LOGI(TAG, "Starting read loop with %zu byte chunks", chunk_bytes);

  for (;;) {
    size_t br = fread(buf, 1, chunk_bytes, fp);
    total += br;
    read_count++;

    if (read_count % 20 == 0) {
      ESP_LOGI(TAG, "Read %d chunks, %zu bytes total", read_count, total);
    }

    if (br < chunk_bytes) {
      ESP_LOGI(TAG, "EOF or short read: got %zu bytes (expected %zu)", br,
               chunk_bytes);
      break;  // EOF or short read
    }

    // Safety check to prevent infinite loops
    if (read_count > 10000) {
      ESP_LOGW(TAG, "Too many reads, breaking loop");
      break;
    }
  }
  int64_t dt = esp_timer_get_time() - t0;

  ESP_LOGI(TAG, "bench_vfs_fread %s %u bytes in %lld us: %.1f KB/s (%.2f MB/s)",
           path, (unsigned)total, (long long)dt,
           (total / 1024.0) / (dt / 1000000.0),
           ((total / 1024.0) / (dt / 1000000.0)) / 1024.0);

  heap_caps_free(buf);
  fclose(fp);  // Close first, stream may still touch its buffer
  if (stdio_buf) heap_caps_free(stdio_buf);
}

static void bench_safe_fread(const char *path) {
  // Check available memory before allocation
  size_t free_internal = heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
  ESP_LOGI(TAG, "Available internal memory: %zu bytes", free_internal);

  FILE *fp = fopen(path, "rb");
  if (!fp) {
    ESP_LOGE(TAG, "fopen(%s) failed", path);
    return;
  }

  // Get file size for progress tracking
  fseek(fp, 0, SEEK_END);
  long file_size = ftell(fp);
  fseek(fp, 0, SEEK_SET);
  ESP_LOGI(TAG, "File size: %ld bytes (%.1f KB)", file_size,
           file_size / 1024.0);

  size_t chunk_bytes = DMA_BUF_PREFERRED_KB * 1024;
  uint8_t *buf =
      (uint8_t *)heap_caps_aligned_alloc(32, chunk_bytes, MALLOC_CAP_DMA);

  if (!buf) {
    ESP_LOGE(TAG, "No DMA read buffer available");
    fclose(fp);
    return;
  }

  // Validate buffer alignment
  ESP_LOGI(TAG, "DMA buffer allocated at 0x%p, size %zu bytes", buf,
           chunk_bytes);
  ESP_LOGI(TAG, "Buffer alignment check: %s",
           ((uintptr_t)buf % 32 == 0) ? "OK" : "FAIL");

  ESP_LOGI(TAG, "Safe fread: %s in %u KB chunks...", path,
           (unsigned)(chunk_bytes / 1024));

  int64_t t0 = esp_timer_get_time();
  size_t total = 0;
  int read_count = 0;

  ESP_LOGI(TAG, "Starting safe read loop with %zu byte chunks", chunk_bytes);

  for (;;) {
    size_t br = fread(buf, 1, chunk_bytes, fp);
    total += br;
    read_count++;

    // Progress logging every 20 reads
    if (read_count % 20 == 0) {
      ESP_LOGI(TAG, "Read %d chunks, %zu bytes total (%.1f%% complete)",
               read_count, total, (total * 100.0) / file_size);
    }

    // Check for EOF or short read (end of file)
    if (br < chunk_bytes) {
      ESP_LOGI(TAG, "EOF reached: got %zu bytes (expected %zu), file complete",
               br, chunk_bytes);
      break;  // EOF or short read - file is complete
    }

    // Safety check to prevent infinite loops
    if (read_count > 10000) {
      ESP_LOGW(TAG, "Too many reads (%d), breaking loop for safety",
               read_count);
      break;
    }

    // Additional safety check based on file size
    if (file_size > 0 && total >= file_size) {
      ESP_LOGI(TAG, "Read complete file (%zu bytes)", total);
      break;
    }
  }

  int64_t dt = esp_timer_get_time() - t0;

  ESP_LOGI(TAG, "Safe fread %s %u bytes in %lld us: %.1f KB/s (%.2f MB/s)",
           path, (unsigned)total, (long long)dt,
           (total / 1024.0) / (dt / 1000000.0),
           ((total / 1024.0) / (dt / 1000000.0)) / 1024.0);

  // Verify we read the complete file
  if (file_size > 0 && total == file_size) {
    ESP_LOGI(TAG, "✓ Complete file read successfully");
  } else if (file_size > 0) {
    ESP_LOGW(TAG, "⚠ Partial read: %zu/%ld bytes (%.1f%%)", total, file_size,
             (total * 100.0) / file_size);
  }

  heap_caps_free(buf);
  fclose(fp);
}

// dump_card_state removed for simplicity

/* ---- SD init/mount (SPI @ 20 MHz, stronger drive) ---- */
static esp_err_t init_and_mount_sdcard_at(int max_freq_khz) {
  ESP_LOGI(TAG, "Initializing SD (SPI mode) @ %d kHz...", max_freq_khz);
  sdmmc_host_t host = SDSPI_HOST_DEFAULT();
  host.slot = s_host_slot;  // HSPI
  host.max_freq_khz = max_freq_khz;

  // Ensure CS idles high prior to bus init
  gpio_config_t cs_cfg = {
      .pin_bit_mask = 1ULL << SD_CS,
      .mode = GPIO_MODE_OUTPUT,
      .pull_up_en = GPIO_PULLUP_DISABLE,
      .pull_down_en = GPIO_PULLDOWN_DISABLE,
      .intr_type = GPIO_INTR_DISABLE,
  };
  gpio_config(&cs_cfg);
  gpio_set_level(SD_CS, 1);

  spi_bus_config_t bus_cfg = {.mosi_io_num = SD_MOSI,
                              .miso_io_num = SD_MISO,
                              .sclk_io_num = SD_SCK,
                              .quadwp_io_num = -1,
                              .quadhd_io_num = -1,
                              .max_transfer_sz = 128 * 1024};
  CHECK(spi_bus_initialize(host.slot, &bus_cfg, SPI_DMA_CH_AUTO),
        "spi_bus_initialize");
  // Allow shifters/power to settle before card init
  vTaskDelay(pdMS_TO_TICKS(20));

  sdspi_device_config_t slot_cfg = SDSPI_DEVICE_CONFIG_DEFAULT();
  slot_cfg.gpio_cs = SD_CS;
  slot_cfg.host_id = host.slot;

  esp_vfs_fat_sdmmc_mount_config_t mount_cfg = {
      .format_if_mount_failed = false,
      .max_files = 5,
      .allocation_unit_size = 0,
      .disk_status_check_enable = false};

  esp_err_t err = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &host, &slot_cfg,
                                          &mount_cfg, &s_card);
  if (err != ESP_OK) {
    // Retry once on timeout by resetting the bus
    if (err == ESP_ERR_TIMEOUT) {
      unmount_and_free_bus();
      vTaskDelay(pdMS_TO_TICKS(50));
      // Re-init bus and retry mount
      if (spi_bus_initialize(host.slot, &bus_cfg, SPI_DMA_CH_AUTO) == ESP_OK) {
        vTaskDelay(pdMS_TO_TICKS(20));
        err = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &host, &slot_cfg, &mount_cfg,
                                      &s_card);
      }
    }
    if (err != ESP_OK) {
      ESP_LOGE(TAG, "mount/init failed: %s", esp_err_to_name(err));
      return err;
    }
  }
  sdmmc_card_print_info(stdout, s_card);
  ESP_LOGI(TAG, "card->max_freq_khz=%d (host asked %d)", s_card->max_freq_khz,
           max_freq_khz);
  return ESP_OK;
}

static void unmount_and_free_bus(void) {
  if (s_card) {
    esp_vfs_fat_sdcard_unmount(MOUNT_POINT, s_card);
    s_card = NULL;
  }
  spi_bus_free(s_host_slot);
}

/* ---- Run it in a modest stack to free INTERNAL RAM ---- */
static void bench_task(void *arg) {
  // First mount: bench immediately
  if (init_and_mount_sdcard_at(26000) != ESP_OK) {
    vTaskDelete(NULL);
    return;
  }
  unmount_and_free_bus();

  // Second mount: ensure fast path
  vTaskDelay(pdMS_TO_TICKS(50));
  if (init_and_mount_sdcard_at(26000) != ESP_OK) {
    vTaskDelete(NULL);
    return;
  }
  bench_vfs_fread(TEST_FILE_VFS_LARGE);
  bench_safe_fread(TEST_FILE_VFS_LARGE);
  unmount_and_free_bus();
  ESP_LOGI(TAG, "Bench complete.");
  vTaskDelete(NULL);
}

void print_memory_info(void) {
  ESP_LOGI(TAG, "8-bit total/free/largest: %u / %u / %u",
           (unsigned)heap_caps_get_total_size(MALLOC_CAP_8BIT),
           (unsigned)heap_caps_get_free_size(MALLOC_CAP_8BIT),
           (unsigned)heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));

  ESP_LOGI(TAG, "DMA total/free/largest:   %u / %u / %u",
           (unsigned)heap_caps_get_total_size(MALLOC_CAP_DMA),
           (unsigned)heap_caps_get_free_size(MALLOC_CAP_DMA),
           (unsigned)heap_caps_get_largest_free_block(MALLOC_CAP_DMA));

  ESP_LOGI(TAG, "INTERNAL total/free:      %u / %u",
           (unsigned)heap_caps_get_total_size(MALLOC_CAP_INTERNAL),
           (unsigned)heap_caps_get_free_size(MALLOC_CAP_INTERNAL));

#ifdef CONFIG_SPIRAM
  ESP_LOGI(TAG, "SPIRAM total/free/largest:%u / %u / %u",
           (unsigned)heap_caps_get_total_size(MALLOC_CAP_SPIRAM),
           (unsigned)heap_caps_get_free_size(MALLOC_CAP_SPIRAM),
           (unsigned)heap_caps_get_largest_free_block(MALLOC_CAP_SPIRAM));
#endif
}

void app_main(void) {
  ESP_LOGI(TAG, "Starting SD benchmark...");
  print_memory_info();

  //   Smaller stack (10 KB) so large INTERNAL buffers are more likely to
  //   succeed
  const uint32_t stack_words = (10 * 1024) / sizeof(StackType_t);
  xTaskCreatePinnedToCore(bench_task, "bench_task", stack_words, NULL,
                          tskIDLE_PRIORITY + 1, NULL, tskNO_AFFINITY);
}
